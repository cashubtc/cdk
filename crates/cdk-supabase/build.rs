//! Build script for cdk-supabase that generates migration embedding code.

fn main() {
    let migration_path = std::path::Path::new("migrations");
    let out_dir =
        std::path::PathBuf::from(std::env::var("OUT_DIR").expect("OUT_DIR is set by Cargo"));
    let dest_path = out_dir.join("migrations_supabase.rs");
    let mut out_file = std::fs::File::create(&dest_path).expect("Failed to create migrations.rs");

    let mut files = Vec::new();
    if let Ok(entries) = std::fs::read_dir(migration_path) {
        for entry in entries.flatten() {
            let path = entry.path();
            if path.is_file() && path.extension().and_then(|s| s.to_str()) == Some("sql") {
                files.push(path);
            }
        }
    }
    files.sort();

    use std::io::Write;
    writeln!(out_file, "/// @generated").expect("Failed to write to migrations file");
    writeln!(out_file, "/// Auto-generated by build.rs")
        .expect("Failed to write to migrations file");
    writeln!(
        out_file,
        "pub static MIGRATIONS: &[(&str, &str, &str)] = &["
    )
    .expect("Failed to write to migrations file");

    for path in files {
        let name = path
            .file_name()
            .expect("Migration file should have a name")
            .to_str()
            .expect("Migration filename should be valid UTF-8");

        // Copy to OUT_DIR for include_str
        let dest_migration_file = out_dir.join(name);
        std::fs::copy(&path, &dest_migration_file)
            .expect("Failed to copy migration file to OUT_DIR");

        writeln!(
            out_file,
            "    (\"supabase\", \"{name}\", include_str!(r#\"{name}\"#)),"
        )
        .expect("Failed to write migration entry");
        println!("cargo:rerun-if-changed={}", path.display());
    }

    writeln!(out_file, "];").expect("Failed to write to migrations file");
}
